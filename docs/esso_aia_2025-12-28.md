# ESSO-Driven Algorithm Improvement Analysis (MPRD) — 2025-12-28

This note summarizes an ESSO (Evolutionary State Space Optimizer) pass over the MPRD ESSO‑IR v1 models found under `internal/tools/evolver/examples/mprd/`.

## What Ran

### Baseline gates

Self‑verification (candidate == reference) using the ESSO Z3 hard gate:

```bash
python3 -m internal.tools.evolver verify <model.yaml> --reference <model.yaml>
```

### Quick evolution sweep (search + small fitness caps)

One‑generation sweep used to identify “low‑hanging” state‑space reductions while keeping runtime bounded:

- `--generations 1 --population 4 --seed 0 --timeout-ms 800`
- bounded prefilter: `--bounded-max-states 100 --bounded-max-depth 5 --bounded-max-param-values 2 --bounded-max-param-combos 8`
- fitness reachable estimate: `--reachable-max-states 50 --reachable-max-depth 6 --reachable-max-param-values 2 --reachable-max-param-combos 8`

Artifacts written to: `internal/tools/evolver/runs/analysis_2025-12-28_quick/`.

### Targeted deeper evolution (example)

For `tokenomics_v6/fee_lanes_bcr_caps`, a deeper run recovered a stronger verified reduction:

```bash
python3 -m internal.tools.evolver evolve internal/tools/evolver/examples/mprd/tokenomics_v6/fee_lanes_bcr_caps.yaml \
  --generations 4 --population 10 --seed 0 --timeout-ms 800 \
  --output internal/tools/evolver/runs/analysis_2025-12-28_deep/fee_lanes_bcr_caps
```

## Baseline Gate Results (Z3 verify)

Self‑verify results for the models under `internal/tools/evolver/examples/mprd/`:

- **PASS (Inv + EQ):** all except the four listed below.
- **FAIL (InvNotInductive, EQ=PASS):**
  - `internal/tools/evolver/examples/mprd/autopilot_controller.yaml`
  - `internal/tools/evolver/examples/mprd/proof_market_slot.yaml`
  - `internal/tools/evolver/examples/mprd/mining/work_submission.yaml`
  - `internal/tools/evolver/examples/mprd/mining/work_verification.yaml`

### Failure diagnoses (from the Z3 CE + kernel replay)

- `autopilot_controller.yaml`
  - CE action: `add_critical`
  - Post failure: invariant `I12_AttentionBudget` violated (post changes `critical_incidents`).
  - Fix direction: strengthen `add_critical` guard (or adjust `I12_AttentionBudget`) so the post‑state stays within budget.

- `proof_market_slot.yaml`
  - CE action: `commit` with `deposit=1` from a state where `total_deposits=10`
  - Post failure: `PostStateType` (domain overflow): `total_deposits` becomes `11` while the type is `int[0,10]`.
  - Fix direction: add a cap guard (`total_deposits + deposit <= 10`) or enlarge the bounded domain; apply similarly anywhere an update can exceed an `int` bound.

- `mining/work_submission.yaml`, `mining/work_verification.yaml`
  - CE action: `reject`
  - Post failure: invariant `InvalidImpliesObjectiveFailure` violated (phase changes but objective‑failure condition not enforced).
  - Fix direction: update `reject` to ensure the objective failure flag/condition is set, or strengthen the guard/invariant depending on intended semantics.

## Fixes Applied (2025-12-28)

The four inductiveness failures above were remediated in-place (under `internal/tools/evolver/examples/mprd/`) and now **self-verify** with cross-solver agreement (`verify --crosscheck-solvers z3,cvc5`):

- `autopilot_controller.yaml`
  - Change: make `tick_hour`, `update_failure_rate`, and `add_critical` simultaneously **auto-degrade** `mode` to `Assisted` when their updates would violate I10–I12 (prevents post-invariant violations).
- `proof_market_slot.yaml`
  - Change: add cap guards to prevent bounded-int overflow:
    - `commit`: `total_deposits + deposit <= 10`
    - `settle`: `total_payouts + payout <= 10`
  - Change: strengthen `settle` guard with `job_hash_present` to preserve `I7_SoundnessBinding` when transitioning to `Settled`.
- `mining/work_submission.yaml`, `mining/work_verification.yaml`
  - Change: strengthen `reject` guard with the objective-failure condition (`proof_valid==0 || spec_satisfied==0`) to preserve `InvalidImpliesObjectiveFailure`.

## Verified Improvements Found

### 1) `optimistic_relay_claim` (quick sweep)

- Reference: `internal/tools/evolver/examples/mprd/optimistic_relay_claim.yaml`
- Best verified candidate: `internal/tools/evolver/runs/analysis_2025-12-28_quick/optimistic_relay_claim/best.yaml`
- Change: M1 domain shrink on internal counter:
  - `round_count: int[0,4] → int[0,3]`
- Fitness delta (default fitness config):
  - `log2_upper_bound`: `5.6439 → 5.3219` (smaller); `reachable_estimate` unchanged.
- Cross‑checked: verified by **Z3 + CVC5** via `verify --crosscheck-solvers z3,cvc5`.

### 2) `fee_lanes_bcr_caps` (deep run)

- Reference: `internal/tools/evolver/examples/mprd/tokenomics_v6/fee_lanes_bcr_caps.yaml`
- Best verified candidate: `internal/tools/evolver/runs/analysis_2025-12-28_deep/fee_lanes_bcr_caps/best.yaml`
- Change: M1 domain shrink on internal accumulator:
  - `offset_total: int[0,12] → int[0,9]`
- Fitness delta (default fitness config):
  - `log2_upper_bound`: `14.8018 → 14.4232` (smaller); `reachable_estimate` unchanged.

## (E)piplexity framing (paper-faithful alignment)

This section aligns our ESSO “bounded verification” metrics with Finzi et al., *From Entropy to Epiplexity* (arXiv:2601.03220v1) ([paper](https://arxiv.org/abs/2601.03220)).

### Key correction

In the paper, **epiplexity is not “entropy under a budget.”** It is the **model/program bits** in a *time-bounded MDL* (two-part code) decomposition: (model bits) + (data-given-model bits), under a compute-bounded observer ([paper](https://arxiv.org/abs/2601.03220)).

So the closest ESSO correspondence is:
- **epiplexity-like term** \(\approx\) *bits to describe the best bounded “verification model”* (invariants/lemmas/abstractions we can validate under a budget),
- **time-bounded entropy-like term** \(\approx\) *residual brute-force footprint* that still must be explored/estimated under that budget.

### A tighter isomorphism table

| Finzi et al. (compute-bounded MDL) | ESSO / verification analogue |
| --- | --- |
| Bounded observer class (programs must run within time bound) | Verifier pipeline under budget \(B\) (timeouts, max-states/depth, solver limits) |
| **Epiplexity** = model/program bits (structure extracted) | `kernel_complexity` / invariant kernel size / proof artifact size (calibrated to bits if possible) |
| **Time-bounded entropy** = data bits given model (residual) | `log2(reachable_estimate_B)` (residual exploration footprint under budget) |
| Ordering/factorization affects what is learnable | ICE schedule / constraint ordering / escalation order changes what is found under same budget |
| Computation can increase bounded information | ESSO mutations can increase *extractable* invariants under fixed budgets |

Our `log2_upper_bound` remains useful as a **Shannon-like ceiling** (syntactic/worst-case state space upper bound), but it should not be treated as “the other half” of the epiplexity decomposition.

### Suggested renaming (to avoid category error)

If we keep the existing numeric fields:
- Let \(U(IR)\triangleq \texttt{log2_upper_bound}(IR)\).
- Let \(H_B^{ver}(IR)\triangleq \log_2(\texttt{reachable_estimate}_B(IR))\). (This is the *time-bounded entropy analogue*.)
- Let \(E_B^{ver}(IR)\triangleq \texttt{kernel_complexity}_B(IR)\). (This is the *epiplexity analogue*.)

Then a “bounded verification MDL” analogue is:

\[
S_B^{ver}(IR) \;:=\; E_B^{ver}(IR) + H_B^{ver}(IR).
\]

And two practical derived ratios:
- **Reachability compression ratio** (what we already implicitly use):
  \[
  C_B^{reach}(IR) := 1 - \frac{H_B^{ver}(IR)}{U(IR)}.
  \]
- **MDL structure fraction** (epiplexity-flavored):
  \[
  C_B^{mdl}(IR) := \frac{E_B^{ver}(IR)}{E_B^{ver}(IR)+H_B^{ver}(IR)}.
  \]

### Soundness note (keep it bulletproof)

Budget and “coverage” govern *whether* we discover a useful invariant/kernel under compute constraints; they should not appear inside the **soundness theorem** itself.
Soundness is the standard 3-condition pattern once an invariant \(I\) is found and checked (no solver UNKNOWN):
1) \(Init \Rightarrow I\)
2) \(I \wedge Trans \Rightarrow I'\) (inductive)
3) \(I \Rightarrow P\)

Coverage/structural diversity belongs in a separate “learnability under budget” discussion, consistent with the paper’s theme: compute affects extractability, not ground-truth validity ([paper](https://arxiv.org/abs/2601.03220)).

## Observations (Why Many Models Don’t Improve Under Current Operators)

Common reasons the sweep returns `best == reference`:

- Too few non‑observable variables of shrinkable kinds (`int/enum/bitvec`) → little to merge/decompose/shrink.
- “Boundary‑literal coupling”: min/max constants hardcoded throughout guards can reduce mutation yield for bounded ints (domain shrinks can invalidate literals, depending on typechecker rules).
- Some models are expensive with the bounded (non‑Z3) prefilter enabled (notably `proof_market_slot`); for quick sweeps use `--no-bounded-prefilter` and cap reachable‑estimate (`--reachable-max-*`).

## Tooling Tweaks Applied in This Workspace

Two practical evolver improvements were made locally (note: `internal/` is gitignored in this repo):

- `internal/tools/evolver/ir/schema.py`: treat bounded int min/max as **variable domains**, not a restriction on int literals in `=, !=, <, <=, >, >=` comparisons. This reduces unnecessary validation failures and improves mutation headroom for M1.
- `internal/tools/evolver/__main__.py`: add `evolve` CLI flags to cap fitness reachable‑state estimation (`--reachable-max-*`) so heavy models can be analyzed without changing code.

Validation: `python3 -m pytest internal/tools/evolver/evidence -q` (40 tests).

## Model→Code Sync Gap (Highest Remaining ROI)

**Gap:** multiple parts of the repo consume “ESSO‑verified kernels” (Rust/TS), but there was no built-in drift detector. After fixing inductiveness issues in the YAML models, generated kernel artifacts could remain stale and silently diverge.

Example (fixed in this workspace):
- `tools/operator-ui/src/generated/autopilotKernel.ts` and `tools/operator-ui/src/generated/autopilot_controller/` still embedded the old IR hash (`3f2e45c3…`) after the model moved to `779e48bb…`.

**New ESSO CLI features added to close the gap:**

- `sync`: verify generated kernel headers match the model IR hash; `--fix` regenerates in place.
- `codegen`: generate Rust and/or TypeScript kernels from a model (optionally requiring VERIFIED by passing `--reference`).

Regenerate Autopilot kernels (TS + Rust) from the updated model:

```bash
python3 -m internal.tools.evolver --pretty sync internal/tools/evolver/examples/mprd/autopilot_controller.yaml \
  --ts tools/operator-ui/src/generated/autopilotKernel.ts \
  --rust tools/operator-ui/src/generated/autopilot_controller \
  --fix
```

## Remaining Gaps (Beyond Sync)

- **Coverage gap:** `crates/mprd-core/src/tokenomics_v6/` is a large pure state machine (`TokenomicsV6::apply`) but only a few sub-kernels are modeled today under `internal/tools/evolver/examples/mprd/tokenomics_v6/`.
- **Kernel adoption gap:** some runtime logic duplicates “verified kernel” behavior instead of calling the generated chokepoint (e.g., `crates/mprd-adapters/src/circuit_breaker.rs` reimplements the circuit breaker instead of using `crates/mprd-adapters/src/verified_kernels/executor_circuit_breaker`).
- **Batch gates gap:** there is still no one-shot “verify/sync everything” command wired into CI (directory sweep + cross-solver agreement + model→code sync).

## Post-Fix Evolution Notes

After applying the fixes, a small evolve pass was run for the remediated models under `internal/tools/evolver/runs/analysis_2025-12-28_fix/`.
Within the tested budgets, these models did not produce a verified candidate strictly better than the reference (`best == reference`), though they now admit verified candidates and can participate in search.

Additionally, a full MPRD sweep (all models under `internal/tools/evolver/examples/mprd/`) was run with bounded prefilter disabled for runtime stability:

- results: `internal/tools/evolver/runs/analysis_2025-12-28_sweep_nobounded/`
- improvements found: `optimistic_relay_claim` and `fee_lanes_bcr_caps` (no new wins beyond those).

## Recommended Next Steps

1. Keep models **inductive first**: ensure every action preserves invariants (and bounded-int domains) by construction. The four inductiveness failures listed earlier in this doc are fixed as of 2025-12-28.
2. Add a **model→code drift gate** in CI: run `sync` for each generated kernel target (TS/Rust) and block merges when any are `OUT_OF_SYNC` (or run `--fix` in a dedicated regen step).
3. For high‑cost models, run `evolve` with tighter `--bounded-max-*` and `--reachable-max-*` caps to quickly find any reductions, then widen caps for final scoring.
4. If broader reductions are desired, consider adding mutation operators that:
   - introduce derived/summary state (state‑abstraction variables) with exact encode/decode,
   - or strengthen guards in a semantics‑preserving way when a post failure is guaranteed under current invariants.
